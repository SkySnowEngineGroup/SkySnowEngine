# RenderSystem的设计与介绍

## 1. GPUResource回收

### 1.1 基础知识

#### 1. Pod&Trivial数据

POD全称: Plain Old Data,中文字面意思平凡普通的老旧数据。历史原因来说，是C++为了兼容C的内存布局而设计的。

POD类型，说明数据是普通的数据，数据对象本身不包含虚函数，内嵌复杂的成员函数，其可以直接用C语言中的struct来表达。在C++中Struct与class的区别并不是很大，但是在C中的Struct是纯数据类型。因此在C++中POD有两个基础属性

1. 支持静态的初始化
2. 编译C++中的POD类型得到的内存布局与C编译Struct的内存布局相同

具体C++11中将POD类型划分为两个概念：

1. Trivial类型
2. Standard Layout类型

**Trivial类型**

平凡的数据类型需要遵循的规定如下

1. 拥有平凡的构造及析构函数。简单说，如果类内不定义构造函数，编译器会默认生成一个平凡构造函数，但是如果类内包含虚函数则不会生成平凡的构造函数；在类内重载了无参默认构造函数，那么也不是平凡构造函数，C语言中是没有对象这个概念的；可以使用default来标记无参默认构造函数，以此让编译器生成平凡的默认构造函数
2. 拥有平凡拷贝及移动构造函数。
3. 拥有平凡的拷贝赋值及移动赋值操作符
4. 不包含虚函数及父类

**Standard Layout标准布局**

标准布局需要遵循的规定如下

1. 类内非静态成员拥有相同访问权限(C语言中Struct的范围权限默认为public，都是一样的)
2. 类或结构体存在继承时，需满足以下两个条件
   1. 派生类中有非静态成员，其只能有一个基类，该基类仅能包含静态成员
   2. 派生类中不包含非静态成员，基类中包含非静态成员
   3. 派生类中有非静态成员，基类中没有静态成员，基类静态成员类型不能与派生类相同
3. 类中第一个非静态成员变量与基类类型不同
4. 没有虚函数及虚基类
5. 派生类非静态成员符合标准布局类型，基类也需符合标准布局

POD类型作用

1. 字节赋值，直接使用memset及memcpy对POD类型进行初始化
2. 提供对C内存布局的兼容
3. 保证静态初始化是安全有效，用于提供程序性能

#### 2. 内存模型

​	C++11中原子操作的很多函数都有std::memory_order参数，这个参数就是内存模型，它并不是POD的内存布局，而是一种数据同步模型，专业术语是:储存一致性模型(作为对同一时间的读写操作进行排序)。c++11共定义了6种类型，根据作用可以分为4类(C++链接:https://en.cppreference.com/w/cpp/atomic/memory_order):

1. **memory_order_relaxed**: 同一程序内，按照代码顺序进行执行

2. **memory_order_release&memory_order_acquire**: 线程A&B，A线程Release后，B线程Acquire能保证读到的一定是最新被修改过的值；保证发生在A-Release前的所有写操作，在B-Acquire后都能读到最新值

3. **memory_order_release&memory_order_consume**: 2中模型的同步是针对所有的对象，当前这种是针对依赖该操作所涉及到的对象。例如: 这种操作作用在变量a上，而s = a+b;那s依赖a，但b不依赖a；还包括循环依赖问题，例如: t = s +1,因为s依赖a，那t其实也依赖于a
4. **memory_order_seq_cst**: 顺序一致性模型，c++11原子操作默认模型；为每一个变量都执行2中的Release-Acquire操作，因此是四种类型中最慢

volatile关键字: 仅仅保证数据只在内存中读写，直接操作即不能保证atomic，也不能保证memory order。在竞争不敏感的环境中用来做flag，没太大问题。在vistual studio中，每一个被volatile修饰的变量，写具有Release语义，读具有volatile语义。但标准的Volatile并不太适用于多线程编程

x86系统中Release-Acquire是自动获取，最终形成一个memory_order_seq_cst模型，因此绝大多数情况下，memory_order_relaxed其实并没什么用

#### 3.原子操作

std::atomic<T>是一个模板类，它定义了一些atomic应该具有的通用操作，这些操作可以应用到所有的TrivialCopyable的类型，即上文所说的POD数据类型。下面简单整理一下关于原子操作的接口规定

##### 1. Store赋值

将一个值赋值给目标值，具体代码如下

```c++
void store(T desr, memory_order m = memory_order_seq_cst) noexcept;
void store(T desr, memory_order m = memory_order_seq_cst) volatile noexcept;
T operator=(T d) noexcept;
T operator=(T d) volatile noexcept;
```

其中m值在某些编译器下只能取以下三个值:memory_order_consume，memory_order_acquire，memory_order_acq_rel

##### 2. load读取

读取原子变量的值，operator T是load的简化版本，内部调用的是load(memory_order_seq_cst)形式

```c++
T load(memory_order m = memory_order_seq_cst) const volatile noexcept;
T load(memory_order m = memory_order_seq_cst) const noexcept;
operator T() const volatile noexcept;
operator T() const noexcept;
```

##### 3. exchange交换

交换，赋值后返回变量赋值前的值。exchange也称为read-modify-write操作

```c++
T exchange(T desr, memory_order m = memory_order_seq_cst) volatile noexcept;
T exchange(T desr, memory_order m = memory_order_seq_cst) noexcept;
```

##### 4. weak(CAS操作)

具体接口如下

```c++
bool compare_exchange_weak(T& expect, T desr, memory_order s, memory_order f) volatile noexcept;
bool compare_exchange_weak(T& expect, T desr, memory_order s, memory_order f) noexcept;
bool compare_exchange_weak(T& expect, T desr, memory_order m = memory_order_seq_cst) volatile noexcept;
bool compare_exchange_weak(T& expect, T desr, memory_order m = memory_order_seq_cst) noexcept;
```

这便是C++中的自旋锁(CAS)所使用的接口,其具体的操作流程为

将原子对象T的值与expect的值进行对比，如果相等，那么使用desr替换原子对象T的值

将原子对象T的值与expect的值进行对比，如果不等，那么使用原子对象T的值替换expect的值

weak操作版本允许返回伪false，有可能原子对象T的值与expect物理内容相等也是返回false。但是可以在某些平台获取较好性能，在某些循环中也是可接受的。

##### 5. strong(CAS操作)

具体接口如下

```c++
bool compare_exchange_strong(T& expect, T desr, memory_order s, memory_order f) volatile noexcept;
bool compare_exchange_strong(T& expect, T desr, memory_order s, memory_order f) noexcept;
bool compare_exchange_strong(T& expect, T desr, memory_order m = memory_order_seq_cst) volatile noexcept;
bool compare_exchange_strong(T& expc, T desr, memory_order m = memory_order_seq_cst) noexcept;
```

这是Weak的加强版本，适用于非循环中，其具体的操作流程与weak相同，但是其不会返回伪false，但是在循环算法中，其性能是比weak差一些的。

##### 6. 特化接口

fetch_add：该函数将原子对象封装的值加上v，同时返回原子对象的旧值

```c++
// T is integral
T fetch_add(T v, memory_order m = memory_order_seq_cst) volatile noexcept;
T fetch_add(T v, memory_order m = memory_order_seq_cst) noexcept;
// T is pointer
T fetch_add(ptrdiff_t v, memory_order m = memory_order_seq_cst) volatile noexcept;
T fetch_add(ptrdiff_t v, memory_order m = memory_order_seq_cst) noexcept;
```

fetch_sub：该函数将原子对象封装的值减去v，同时返回原子对象的旧值

```c++
// T is integral
T fetch_sub(T v, memory_order m = memory_order_seq_cst) volatile noexcept;
T fetch_sub(T v, memory_order m = memory_order_seq_cst) noexcept;
// T is pointer
T fetch_sub(ptrdiff_t v, memory_order m = memory_order_seq_cst) volatile noexcept;
T fetch_sub(ptrdiff_t v, memory_order m = memory_order_seq_cst) noexcept;
```

fetch_and，fetch_or，fetch_xor：位操作，将contained按指定方式进行位操作，并返回contained的旧值

```c++
integral fetch_and(integral v, memory_order m = memory_order_seq_cst) volatile noexcept;
integral fetch_and(integral v, memory_order m = memory_order_seq_cst) noexcept;
integral fetch_or(integral v, memory_order m = memory_order_seq_cst) volatile noexcept;
integral fetch_or(integral v, memory_order m = memory_order_seq_cst) noexcept;
integral fetch_xor(integral v, memory_order m = memory_order_seq_cst) volatile noexcept;
integral fetch_xor(integral v, memory_order m = memory_order_seq_cst) noexcept;
```

operator &=，operator |=，operator ^=:  与相应的fetch_*操作不同的是，operator操作返回的是新值:

```c++
T operator &=(T v) volatile noexcept {return fetch_and(v) & v;}
T operator &=(T v) noexcept {return fetch_and(v) & v;}
T operator |=(T v) volatile noexcept {return fetch_or(v) | v;}
T operator |=(T v) noexcept {return fetch_or(v) | v;}
T operator ^=(T v) volatile noexcept {return fetch_xor(v) ^ v;}
T operator ^=(T v) noexcept {return fetch_xor(v) ^ v;}
```

### 2. HazardPointer

