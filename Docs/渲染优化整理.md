# SkySnowEngine中GRI图形API层级优化

## 1. GLGRI

### 1. OGL中拓展函数流程

#### 1. 基础知识

相较于DX来说，OpenGL有一个优点是可以不等某个具体的版本，而根据各个显卡产商针对新功能对OpenGL开发的拓展进行使用。但是有一个缺点，拓展可能功能相同，名字不同，因此需要开发者进行处理。

window对OpenGL支持比较差，因此拓展就是必须要做的了。

虽然功能相同，名字不同，但大致是有迹可循的，一个拓展名字如下

```c++
GL_ARB_multitexture
```

下表线的前一段

GL:表示针对OpenGL核心库的拓展

WGL: 表示针对Windows平台的拓展

GLX：表示针对unix/linux平台的拓展

GLU: 表示针对OpenGL Utility Library的拓展

第二段

ARB: 表示由OpenGL Architecture Review Board(OpenGL管理机构)正适核批的拓展，一般由显卡产商的拓展演变而来，因此优先使用ARB拓展 

EXT: 表示多个硬件产商支持的拓展

NV: 表示nVIDIA公司支持的拓展

ATI: 表示ATI公司支持的拓展

ATIX: 表示ATI公式支持的实验性拓展

SGI: 表示Silicon Graphics(SGI)公司开发的拓展

SGIX: 表示Silicon Graphics(SGI)公司开发的实验性拓展

#### 2. 拓展流程

##### 2.1  查询所有扩展

首先需要查看当前显卡支持的所有的扩展，如下

```c++
const char* extensionsStr = glGetString(GL_EXTENSIONS);
```

该函数返回一个OpenGL的拓展字符串，扩展字符中包含当前显卡所支持的所有扩展名字，不同拓展名字以分号隔开，如下格式

```c++
"GL_ARB_imaging GL_ARB_multitexture GL_ARB_point_parameters ……"
```

需要注意一点，Windows平台上，拓展函数并不通过.lib链接到程序，而是在Runtime时获取。因此，在windows平台使用GLFW+glad组合，也是会面临拓展函数版本问题，因此拓展是有必要的。

##### 2.2 获取函数指针

以GL_ARB_point_parameters为例

首先需定义函数指针类型，如下

```c++
typedef void (APIENTRY * PFNGLPOINTPARAMETERFARBPROC)(GLenum pname,GLfloat param);
typedef void (APIENTRY * PFNGLPOINTPARAMETERFVARBPROC)(GLenum pname,const GLfloat *params);
```

这部分工作可以自己定义，也可以使用SGI提供的glext.h头文件(包含一些函数指针类型的定义)

其次需要定义函数指针，如下

```c++
PFNGLPOINTPARAMETERFARBPROC glPointParameterfARB;
PFNGLPOINTPARAMETERFVARBPROC glPointParameterfvARB;
```

##### 2.3 查询支持

需要检查显卡是否支持该拓展，以便于在Runtime的时候确定是否使用该拓展，例如GL_ARB_point_parameters字段，在2.1中的字段中查询是否有该字段，然后在GLBase中填入isExtensionSupportedPointer函数是否支持的标志位，完整的示例代码如下

```C++
namespace SkySnow
{
    class GLBase
    {
        friend class Imports_GL;
    public:
        static inline bool isExtensionSupportedPointer()
        {
            return isSupportPointer;
        }
     protected:   
        static bool isSupportPointer = false;
    };
}
```

```c++
namespace SkySnow
{
typedef void (APIENTRY * PFNGLPOINTPARAMETERFARBPROC)(GLenum pname,GLfloat param);
typedef void (APIENTRY * PFNGLPOINTPARAMETERFVARBPROC)(GLenum pname,const GLfloat *params);
PFNGLPOINTPARAMETERFARBPROC glPointParameterfARB;
PFNGLPOINTPARAMETERFVARBPROC glPointParameterfvARB; 
	class Imports_GL
	{
     public:
		static void ImportGLExtension()
        {
            //该函数只是示例，真正的代码不会写成这个样子
            //在GLES或者GLimport中判断拓展字段如果支持，将该标志位置为true
			//并且获取拓展函数的指针
            bool isflag = IsCheckExtensionStr("GL_ARB_point_parameters");
            if(isflag)
            {
                glPointParameterfARB = (PFNGLPOINTPARAMETERFARBPROC);
				wglGetProcAddress( "glPointParameterfEXT" );
				glPointParameterfvARB = (PFNGLPOINTPARAMETERFVARBPROC);
				wglGetProcAddress( "glPointParameterfvEXT" );
				GLBase::isSupportPointer = true;
            }
        }
    private:
        static inline bool IsCheckExtensionStr(const string estr)
        {
            const char* extensionsStr = glGetString( GL_EXTENSIONS );
            //查找estr是否存在于extensionsStr中
            //如果存在返回true，不存在返回false
            return true;
        }
	};
}
```

##### 2.4 平台差异

GL_EXTENSIONS 字段在Windows中获取的字段不包含WGL拓展，需要使用WGL_ARB_extensions_string字段。另外，Windows的函数指针类型并不在glext.h中定义，这块我们可以自己定义函数指针类型，也可以使用SGI定义好的，在wglext.h头文件中。

### 2. OGL图形API层级优化

#### 1. OGLBuffer

##### 1. VBO

OGLBuffer主要是封装OpenGL及ES的IndexBuffer&VertexBuffer&ShaderLocalBuffer(SSBO)等buffer资源的创建、绑定、更新数据

其对应OGL主要API如下:

```c++
glGenBuffer(GLsizei n, GLuint *buffers);
glBindBuffer(GLenum target, GLuint buffer);
glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data);
goBufferData(GLenum target, GLsizeiptrARB size, const void *data, GLenum usage);
```

正常创建一个VBO、VAO、EBO、IBO，能减少Static绘制任务时CPU与GPU数据的交互，能减少性能损耗。

在使用C++编程之时，有一种称之为内存池的操作，可以减少内存碎片化、减少Runtime的申请内存的性能损耗。同样的道理其实也是适用于GPU，基于此想法，我们可以对应的对glGenBuffer进行封装，伪代码(UE5处理方式)如下:

```c++
extern int GPUBufferSize = 512;
int NextGPUBufferID = 512;
int BufferCache[GPUBufferSize];
static inline GenBuffers(GLsizei n, GLuint *buffers)
{
    //初次申请GPU内存，将不从BufferCache中取出
    if(n < (GPUBufferSize - NextGPUBufferID))
    {
        memcpy(buffers,&BufferCache[NextGPUBufferID],sizeof(GLuint)*n);
        NextGPUBufferID += n;
    }
    else//初次申请GPU内存，将申请大额的GPU内存出来
    {
        //如果大于预设的池大小，将不再cache托管
        if(n >= GPUBufferSize)
        {
            glGenBuffers(n, buffers);
        }
        else//假设申请的Buffer数量小于预设大小，但是大于剩余的池中未用的数量
        {
            //求出池中剩余未用的buffer数量
            GLsizei leftOver = GPUBufferSize - NextGPUBufferID;
            //将池中剩余的Buffer但是小于n的Buffer拷贝到申请的buffer中
            memcpy(buffers,&BufferCache[NextGPUBufferID],sizeof(GLuint)*leftOver);
            //已经将池中剩余的buffer拷贝进申请的buffers中，重新申请指定大小的buffer
            glGenBuffers(GPUBufferSize,BufferCache);
            //求出目前还差多少个buffer
            n = n - leftOver;
            //申请的buffers移位到已经申请完buffer的id上
            buffers = buffers + leftOver;
            //将差的n个buffer重新拷贝到申请的buffers中
            memcpy(buffers,BufferCache,sizeof(GLuint)*n);
            //记录下一个有效的未使用的buffer在cache中的ID
            NextGPUBufferID = n;
        }
    }
}
```

在代码注释中说明了buffer池的运作机制，这个buffercache的主要作用是，避免在Runtime的时候，向GPU申请Buffer，这种行为是昂贵且不确定性的，在GPU内存吃紧，或者申请释放了过多的GPU内存时，GPU并不能像往常一样，可以在短时间内分配出内存，那么这种操作无疑是可以减缓这种情况发生。另外需要注意的是，需要自行查看自己的程序在运行最复杂的场景，最高会申请多少个Buffer，这样在去设定BufferCache的大小。

另外需要特殊说明的一点是，BufferCache中永远管理的是未被使用的Buffer，但是已经从GPU申请出来的显存并被使用的Buffer显存，归属与资源生命周期的释放管理。因为申请的时候，是申请的连续的一段内存，在释放之时，也是在一个时刻释放一段连续不用的Buffer数组，这比断断续续申请与断断续续释放在一定程度上保证了显存的连续性。

使用此种方式，适用于场景复杂的渲染需要，而渲染任务不是非常重的情况下，其带来的优势并不是非常明显，但可在一定程度上降低GPU的运行的时钟周期。

那么针对于Vulkan&Metal，其是有对应的Allocator来进行处理的。

##### 2. glVertexAttribPointer

**缺陷1:** offset为指针非整数，cpu侧进行整数到指针的转换，GPU侧进行指针到整数的转换(这是一个糟糕的设计思路)
**缺陷2:** 合并两个逻辑上完全独立的操作: 1. 如何从内存提取数据 2. 数据是什么样的
OpenGL的4.3和OpenGL ES 3.1添加若干替代功能用于指定顶点数组:glVertexAttribFormat,glBindVertexBuffers等
单独的glVertexAttribPointer函数，类似以下伪代码功能

```c++
void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer)
{
	glVertexAttrib*Format(index, size, type, normalized, 0);
	glVertexAttribBinding(index, index);
	GLuint buffer;
	glGetIntegerv(GL_ARRAY_BUFFER_BINDING, buffer);
	if(buffer == 0)
		glErrorOut(GL_INVALID_OPERATION); //Give an error.

	if(stride == 0)
		stride = CalcStride(size, type);

	GLintptr offset = reinterpret_cast<GLintptr>(pointer);
	glBindVertexBuffer(index, buffer, offset, stride);
}
```
那么针对于低于OpenGL4版本的驱动层，我们只能通过在OpenGL3中进行拓展的查询，如果不支持，那么就回归到glVertexAttribPointer，如果支持，那么就用新的能力，以求能最大化复用VBO的目的

#### 2. OGLShader

#### 3. OGLTexture

#### 4. OGLRenderState

$$
\[ L(s, \theta, \phi) = exposure \times \sum_{i=0}^n decay^i \times weight \times \frac{L( s_i, \theta_i )}{n} \]
$$

