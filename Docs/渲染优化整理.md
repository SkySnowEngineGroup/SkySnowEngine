# SkySnowEngine中GRI图形API层级优化

## 1. GLGRI

### 1. OGL图形API层级优化

#### 1. OGLBuffer

OGLBuffer主要是封装OpenGL及ES的IndexBuffer&VertexBuffer&ShaderLocalBuffer(SSBO)等buffer资源的创建、绑定、更新数据

其对应OGL主要API如下:

```c++
glGenBuffer(GLsizei n, GLuint *buffers);
glBindBuffer(GLenum target, GLuint buffer);
glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data);
goBufferData(GLenum target, GLsizeiptrARB size, const void *data, GLenum usage);
```

正常创建一个VBO、VAO、EBO、IBO，能减少Static绘制任务时CPU与GPU数据的交互，能减少性能损耗。

在使用C++编程之时，有一种称之为内存池的操作，可以减少内存碎片化、减少Runtime的申请内存的性能损耗。同样的道理其实也是适用于GPU，基于此想法，我们可以对应的对glGenBuffer进行封装，伪代码(UE5处理方式)如下:

```c++
extern int GPUBufferSize = 512;
int NextGPUBufferID = 512;
int BufferCache[GPUBufferSize];
static inline GenBuffers(GLsizei n, GLuint *buffers)
{
    //初次申请GPU内存，将不从BufferCache中取出
    if(n < (GPUBufferSize - NextGPUBufferID))
    {
        memcpy(buffers,&BufferCache[NextGPUBufferID],sizeof(GLuint)*n);
        NextGPUBufferID += n;
    }
    else//初次申请GPU内存，将申请大额的GPU内存出来
    {
        //如果大于预设的池大小，将不再cache托管
        if(n >= GPUBufferSize)
        {
            glGenBuffers(n, buffers);
        }
        else//假设申请的Buffer数量小于预设大小，但是大于剩余的池中未用的数量
        {
            //求出池中剩余未用的buffer数量
            GLsizei leftOver = GPUBufferSize - NextGPUBufferID;
            //将池中剩余的Buffer但是小于n的Buffer拷贝到申请的buffer中
            memcpy(buffers,&BufferCache[NextGPUBufferID],sizeof(GLuint)*leftOver);
            //已经将池中剩余的buffer拷贝进申请的buffers中，重新申请指定大小的buffer
            glGenBuffers(GPUBufferSize,BufferCache);
            //求出目前还差多少个buffer
            n = n - leftOver;
            //申请的buffers移位到已经申请完buffer的id上
            buffers = buffers + leftOver;
            //将差的n个buffer重新拷贝到申请的buffers中
            memcpy(buffers,BufferCache,sizeof(GLuint)*n);
            //记录下一个有效的未使用的buffer在cache中的ID
            NextGPUBufferID = n;
        }
    }
}
```

在代码注释中说明了buffer池的运作机制，这个buffercache的主要作用是，避免在Runtime的时候，向GPU申请Buffer，这种行为是昂贵且不确定性的，在GPU内存吃紧，或者申请释放了过多的GPU内存时，GPU并不能像往常一样，可以在短时间内分配出内存，那么这种操作无疑是可以减缓这种情况发生。另外需要注意的是，需要自行查看自己的程序在运行最复杂的场景，最高会申请多少个Buffer，这样在去设定BufferCache的大小。

另外需要特殊说明的一点是，BufferCache中永远管理的是未被使用的Buffer，但是已经从GPU申请出来的显存并被使用的Buffer显存，归属与资源生命周期的释放管理。因为申请的时候，是申请的连续的一段内存，在释放之时，也是在一个时刻释放一段连续不用的Buffer数组，这比断断续续申请与断断续续释放在一定程度上保证了显存的连续性。

使用此种方式，适用于场景复杂的渲染需要，而渲染任务不是非常重的情况下，其带来的优势并不是非常明显，但可在一定程度上降低GPU的运行的时钟周期。

那么针对于Vulkan&Metal，其是有对应的Allocator来进行处理的。



#### 2. OGLShader

#### 3. OGLTexture

#### 4. OGLRenderState

